<p align="center">
  <a href="https://github.com/infotroph/tree-is-clean/actions"><img alt="tree-is-clean status" src="https://github.com/infotroph/tree-is-clean/workflows/build-test/badge.svg"></a>
</p>

# GitHub action to check for changes in the Git working tree

This is a very simple check to make sure your build doesn't modify files unexpectedly: It simply runs `git status` in your build directory, signals a build failure if the tree is not clean, and reports the full diff in case you want it for debugging.

The original use case was to catch myself when I forgot to check in the new versions of autogenerated documentation files after changing their sources. It is also useful for detecting any files unwantedly written into the working directory, e.g. tests that ought to be using a proper tempdir. If your build *wantedly* writes new files and you only want to check for changes to existing ones, you can ignore the newly added files with `consider-untracked: false`.

## Usage

```
steps:
  - uses: actions/checkout@v1
  - run: ./my_build_script.sh
  - run: ./update_the_documentation.sh 
  - uses: infotroph/tree-is-clean@v1
    with:
      consider-untracked: true
```

To work at all, `tree-is-clean` needs to run inside a Git repository, so call it downstream of `actions/checkout`. To do anything useful, call it downstream of the file manipulations you want to check. I usually call it once at the end, but it would be fine to call it multiple times during the same job if, say, you have many steps and want to fail early if any one of them dirties the working tree.

If the working tree is clean, the action finishes with no output and the build continues. But if any step between `checkout` and `tree-is-clean` changes any files, the build will fail and the log will contain a summary of the changes:

![Screenshot of build failure from a dirty working tree](img/diff-sample.png)
